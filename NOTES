-*- indented-text -*-

Issues
======

1. Sort by X

  - In library items: sort subitems by name, date, etc.

  - In image list view: sort images by name, date, etc. [done]

  Both kinds of sorting should persist across restarts.

2. Dragging library items

  - Dragging a top-level item should move it in the view.

  - Dragging a subfolder should move it in the file system.

3. Renaming library items by editing their name

  - Top level items or albums just change their displayed name

  - Items backed by directories rename the directory.

4. Allow image metadata to be edited

  - Title, caption, copyright, keywords etc. [done, in inspector]

  - Dedicated tagging/keywording UI? (Panel showing tag list, with
  those that are applied sorted forwards and highlighted?)

  - Edit orientation state for simple rotation support. [done]

5. Overlay metadata badges in image view

  - Ratings etc..

6. Command to select RAW vs JPEG source file

  PARTIALLY RESOLVED: added the command, everything updates and caches
  correctly. But decoding full-size RAW data on the fly is too slow to
  be useful. Will probably need to cache a full-size "developed" image,
  and work from that. But the devil is in the details (depth, color
  space, compression, etc..)

7. Custom image list filters

  Normal "build a query" style UI (use NSPredicate and its editor).

  RESOLVED: implemented. But may create a better editing UI later,
  NSPredicateEditor is somewhat clunky.

8. Save filters/queries as smart folders in source list

  The position of the filter item in the library hierarchy controls
  what it filters. E.g. top-level == filter everything, subitem of a
  directory == only filter that directory.

  Once created, selecting the smart folder item activates the
  associated image list and predicate. Opening the predicate editor
  shows the current filter, but editing the predicate doesn't
  immediately commit the changes back to the smart folder. Only once
  the OK button has been clicked will the smart folder's permanent
  state be updated, cancelling returns it to the original state.

  PARTIALLY RESOLVED: added top-level smart folders that filter the
  complete set of images. No way to rename them. No way to drag/create
  them under a normal folder.

9. "Preview" mode where the fullsize image isn't loaded?

10. Viewer should be able to display multiple images?

  As an option? Useful for comparing similar images.. or does it just
  make the images too small to be useful? Perhaps a way of quickly
  flipping through the selection like a stack of cards? (With a
  view-all mode for selecting?)

10. Image groups (aka stacks)

  - Allow multiple images to be grouped

  - The stack can be reordered, the first is used by default

  - Stacks can be expanded to show all images, or collapsed

  - Command to create stacks based on time brackets?

11. Duplicate an image

  - i.e. create a new meta file referencing the same master image(s)

  - not too useful yet, but will be later, e.g. multiple crops of the
  same image

12. Archive volumes

  Mark a directory as the "archive" of a library root. Then:

    - command to move unused files (RAW vs JPEG etc) to the archive,
    - may also copy used files into the archive, for completeness.

  After moving the assets around need to create valid metadata in the
  archive location, and update the metadata in the master to add a
  reference to the "missing" file, probably its name and hash, so that
  it can be found when needed. (The metadata already lists the kinds
  of files that are available, but it may not be saved.)

13. Trashed images

  Add a deleted property to the image, set it when the image is
  "deleted". Add a "Trash" meta-folder to show all deleted images.
  (Requires an expensive full-library scan?) Also add an "Empty Trash"
  command.

14. Libraries and caching

  Even though startup asynchronously loads images, it takes long enough
  to be annoying. The bulk of the time is sucking the metadata out of
  each image, ImageIO parsing it and then us converting it to our own
  format.

  Adding a basic cache of parsed properties helps this, but to make the
  cache fast enough it can only index on base-name, size and mtime of
  each file, which is fragile. And it's going to be hard to GC items
  out of the cache when images are deleted.

  So we need something less ad hoc. It's perhaps time to formalize the
  "image library" concept, along the lines of:

  - each library has a host-unique id (32-bit token), and a persistent
  catalog associated with it

  - the catalog maps relative-path -> file-id

  - file-id is a 32-bit token of some kind, unique to the library

  - arrange proxy and property caches relative to library root, both
  stored in file system. File names are made from library and image ids

  - can't store library or file ids in the .phod file -- rsyncing the
  file to another host or library would leave it in an invalid state.

  - deleting a library purges its cached state. (If we format the
  library's cache as its own subdirectory, we can delete it wholesale.)

  - after startup is complete, GC files from each mounted library that
  no longer exist (and aren't marked archived)

  - no more use of partial hashes to cache files. If files move, we
  regenerate the cache. If an old file is replaced, its mtime had
  better get updated!

  RESOLVED: implemented this, and using it to cache image properties. 

15. Color tint change when switching from proxy to full-size

  Possibly because proxies are matched to sRGB? (This means they're
  also downsampled in the sRGB space, but it's more likely to be a
  gamut clipping issue? Greens seem to be the worst.)
